package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"text/template"
)

const output = "pkg/analyzer/testdata/src/basic/empty_generated.go"

var t = template.Must(template.New("empty").Funcs(map[string]any{
	"ExpandCheck": ExpandCheck,
}).Parse(`package basic

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestEmptyAsserts(t *testing.T) {
	var (
		a    [0]int
		aPtr *[0]int
		s    []int
		m    map[int]int
		ss   string
		c    chan int
	)
	{{ range $i, $pkg := .Pkgs }}
	t.Run("{{ $pkg }}", func(t *testing.T) {
		{{- range $i, $var := $.Vars }}
		{
			{{- range $i, $check := $.InvalidChecks }}
			{{ ExpandCheck $check $pkg $var }}
			{{ end }}}
		{{ end }}
		// Valid {{ $pkg }}s.
		{{ range $i, $var := $.Vars }}
		{
			{{- range $i, $check := $.ValidChecks }}
			{{ ExpandCheck $check $pkg $var }}
			{{ end }}}
		{{ end -}}
	})
	{{ end }}}
`))

type check struct {
	Fn              string   // "Len"
	Args            []string // ["t", "a", "0"]
	DynamicArgIndex int
	ReportedMsg     string // "use assert.Empty"
}

func main() {
	f, err := os.Create(output)
	if err != nil {
		log.Panic(err)
	}
	defer f.Close()

	b := bytes.NewBuffer(nil)

	if err := t.Execute(b, struct {
		Pkgs          []string
		Vars          []string
		InvalidChecks []check
		ValidChecks   []check
	}{
		Pkgs: []string{"assert", "require"},
		Vars: []string{"a", "aPtr", "s", "m", "ss", "c"},
		InvalidChecks: []check{
			{Fn: "Len", Args: []string{"t", "%s", "0"}, DynamicArgIndex: 1, ReportedMsg: "use %s.Empty"},
			{Fn: "Equal", Args: []string{"t", "len(%s)", "0"}, DynamicArgIndex: 1, ReportedMsg: "use %s.Empty"},
			{Fn: "Equal", Args: []string{"t", "0", "len(%s)"}, DynamicArgIndex: 2, ReportedMsg: "use %s.Empty"},
			{Fn: "True", Args: []string{"t", "len(%s) == 0"}, DynamicArgIndex: 1, ReportedMsg: "use %s.Empty"},
			{Fn: "True", Args: []string{"t", "0 == len(%s)"}, DynamicArgIndex: 1, ReportedMsg: "use %s.Empty"},
		},
		ValidChecks: []check{
			{Fn: "Empty", Args: []string{"t", "%s"}, DynamicArgIndex: 1},
		},
	}); err != nil {
		log.Panic(err)
	}

	formatted, err := format.Source(b.Bytes())
	if err != nil {
		fmt.Println(b.String())
		log.Panic(err)
	}

	if _, err := f.Write(formatted); err != nil {
		log.Panic(err)
	}
	if err := f.Close(); err != nil {
		log.Panic(err)
	}
}

// TODO: code generated by dont
